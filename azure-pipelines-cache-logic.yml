jobs:
- job: PrepareDepencies
  displayName: 'Prepare and Cache Dependencies'
  strategy:
    matrix:
      macOS_14:
        vmImage: 'macOS-14'
        artifactName: 'deps-macOS-14'
      macOS_15:
        vmImage: 'macOS-15'
        artifactName: 'deps-macOS-15'

  pool:
    vmImage: $[ variables['vmImage'] ]

  steps:
  - checkout: self
    fetchDepth: 1
    clean: true

  # Cache Homebrew packages
  - task: Cache@2
    displayName: 'Cache Homebrew packages'
    inputs:
      key: 'homebrew-v1 | "$(Agent.OS)" | $(vmImage) | ci/macOS/install_macos_deps.sh | ci/macOS/macos_config.sh'
      restoreKeys: |
        homebrew-v1 | "$(Agent.OS)" | $(vmImage) | ci/macOS/install_macos_deps.sh
        homebrew-v1 | "$(Agent.OS)" | $(vmImage)
      path: /usr/local
      cacheHitVar: HOMEBREW_CACHE_RESTORED

  # TODO: Re-enable after Homebrew cache works
  # Cache source-built dependencies
  # - task: Cache@2
  #   displayName: 'Cache source dependencies'
  #   inputs:
  #     key: 'deps-v1 | "$(Agent.OS)" | $(vmImage) | ci/macOS/install_macos_deps.sh | ci/macOS/macos_config.sh'
  #     path: $(STAGING_AREA)
  #     cacheHitVar: DEPS_CACHE_RESTORED

  # Install dependencies with Homebrew cache awareness
  - script: |
      set -e
      echo "Homebrew cache status: $HOMEBREW_CACHE_RESTORED"

      # Set environment flag for Homebrew installation
      export SKIP_HOMEBREW_INSTALL=${HOMEBREW_CACHE_RESTORED:-false}
      echo "Skip Homebrew install: $SKIP_HOMEBREW_INSTALL"

      # Use original script with cache flag
      ./ci/macOS/install_macos_deps.sh
    displayName: 'Install and build dependencies'
    workingDirectory: $(Build.Repository.LocalPath)

  # Validate Homebrew cache
  - script: |
      set -e
      echo "=== Homebrew cache validation ==="
      if [ "$HOMEBREW_CACHE_RESTORED" = "true" ]; then
        echo "Cache was restored, validating packages..."
        brew list --versions | head -10
        echo "Total Homebrew packages: $(brew list | wc -l)"
      else
        echo "No cache restored, packages will be installed fresh"
      fi

      echo "=== Post-install verification ==="
      echo "Qt version: $(brew list --versions qt@5 || echo 'Not found')"
      echo "CMake version: $(cmake --version | head -1 || echo 'Not found')"
    displayName: 'Validate dependencies'
    workingDirectory: $(Build.Repository.LocalPath)
    condition: always()

  # Create tarball of dependencies for artifact sharing
  - script: |
      set -e
      cd $(Build.Repository.LocalPath)

      # Create dependencies artifact
      if [ -d "staging" ]; then
        echo "Creating dependencies artifact..."
        tar -czf dependencies-$(vmImage).tar.gz staging/
        echo "Artifact size: $(du -sh dependencies-$(vmImage).tar.gz)"
      else
        echo "No staging directory found, creating empty artifact"
        mkdir -p staging
        tar -czf dependencies-$(vmImage).tar.gz staging/
      fi
    displayName: 'Create dependencies artifact'
    workingDirectory: $(Build.Repository.LocalPath)

  # Publish artifact for build jobs
  - task: PublishPipelineArtifact@1
    displayName: 'Publish dependencies artifact'
    inputs:
      targetPath: '$(Build.Repository.LocalPath)/dependencies-$(vmImage).tar.gz'
      artifactName: '$(artifactName)'

  # Debug information
  - script: |
      echo "=== System information ==="
      sw_vers
      echo "=== Disk usage ==="
      df -h /usr/local
      echo "=== Build variables ==="
      echo "vmImage: $(vmImage)"
      echo "artifactName: $(artifactName)"
      echo "Working directory: $(pwd)"
      echo "Staging area: $(ls -la staging/ 2>/dev/null || echo 'Not found')"
    displayName: 'Debug information'
    condition: always()