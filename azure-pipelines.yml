variables:
    QT_FORMULAE: qt@5
    REPO_SLUG: $(Build.Repository.Name)
    CURRENT_COMMIT: $(Build.SourceVersion)
    CACHING_ENABLED: 'true'

trigger:
  branches:
    include:
    - main
    - master
    - dev
    - ci-*
  tags:
    include:
    - v*

pr:
  branches:
    include:
    - main
    - master
    - dev
    - ci-*

stages:
- stage: Builds
  jobs:
  - job: macOSBuilds
    timeoutInMinutes: 90
    strategy:
      matrix:
        macOS_14:
          vmImage: 'macOS-14'
          artifactName: 'macOS-14'
        macOS_15:
          vmImage: 'macOS-15'
          artifactName: 'macOS-15'

    pool:
      vmImage: $[ variables['vmImage'] ]
    steps:
    - checkout: self
      fetchDepth: 0
      clean: true

    # Homebrew Cache
    - task: Cache@2
      inputs:
        key: 'homebrew-v1 | "$(vmImage)" | ci/macOS/install_macos_deps.sh | ci/macOS/macos_config.sh | "$(date +%Y-%m)"'
        path: '$(Pipeline.Workspace)/.homebrew-cache'
        cacheHitVar: 'HOMEBREW_CACHE'
      displayName: 'Cache Homebrew Downloads'
      condition:  and(or(eq(variables['vmImage'], 'macOS-14'), eq(variables['vmImage'], 'macOS-15')), eq(variables['CACHING_ENABLED'], 'true'))

    # Git Repositories Cache
    - task: Cache@2
      inputs:
        key: 'git-repos-v1 | ci/macOS/macos_config.sh | "$(date +%Y-%m)"'
        path: '$(Pipeline.Workspace)/.git-cache'
        cacheHitVar: 'GIT_REPOS_CACHE'
      displayName: 'Cache Git Repositories'
      condition: and(or(eq(variables['vmImage'], 'macOS-14'), eq(variables['vmImage'], 'macOS-15')),  eq(variables['CACHING_ENABLED'], 'true'))

    # Built Dependencies Cache
    - task: Cache@2
      inputs:
        key: 'built-deps-v1 | "$(vmImage)" | ci/macOS/macos_config.sh | ci/macOS/install_macos_deps.sh | "$(date +%Y-%m)"'
        path: '$(Build.Repository.LocalPath)/staging/dependencies'
        cacheHitVar: 'BUILT_DEPS_CACHE'
      displayName: 'Cache Built Dependencies'
      condition: and(or(eq(variables['vmImage'], 'macOS-14'), eq(variables['vmImage'], 'macOS-15')), eq(variables['CACHING_ENABLED'], 'true'))


    - script: ./ci/macOS/install_macos_deps.sh
      displayName: 'Build and Install Dependencies'
      workingDirectory: $(Build.Repository.LocalPath)
    - script: |
            export BUILD_HOST="$(vmImage)"
            export ACCOUNT_NAME=`echo $REPO_SLUG | awk -F "/" '{print $1}'`
            export PROJECT_NAME=`echo $REPO_SLUG | awk -F "/" '{print $2}'`
            export USERNAME="azure-pipelines"
            export BUILD_REPO_URL=$(Build.Repository.Uri)
            export RUN_ID=$(Build.BuildId)
            export RUN_NUMBER=$(Build.BuildNumber)
            export JOB_ID=$(System.JobId)
            export JOB_NAME=$(System.JobName)
            export RUNNER_ARCH=$(Agent.OSArchitecture)
            export MACOSX_DEPLOYMENT_TARGET=11.0
            ./ci/macOS/build_azure_macos.sh
      displayName: 'Build Scopy'
      workingDirectory: $(Build.Repository.LocalPath)
    - script: ./ci/macOS/package_darwin.sh
      displayName: 'Create Scopy.dmg'
      workingDirectory: $(Build.Repository.LocalPath)
    - script: cp -R staging ${BUILD_ARTIFACTSTAGINGDIRECTORY}
      displayName: 'Copy Staging Dir'
      workingDirectory: $(Build.Repository.LocalPath)
    - script: |
            set -e
            echo "TF_BUILD = ${TF_BUILD}"
            echo "ACCOUNT_NAME = " ${ACCOUNT_NAME}
            echo "PROJECT_NAME = " ${PROJECT_NAME}
            MACOS_VERSION=$(/usr/libexec/PlistBuddy -c "Print:ProductVersion" /System/Library/CoreServices/SystemVersion.plist)
            DEPLOY_FILE=Scopy-macos${MACOS_VERSION}-${CURRENT_COMMIT:0:7}.dmg
            cp build/ScopyApp.zip ${BUILD_ARTIFACTSTAGINGDIRECTORY}
            if [ -e build/Scopy.dmg ]; then
              cp build/Scopy.dmg ${BUILD_ARTIFACTSTAGINGDIRECTORY}/${DEPLOY_FILE}
              cd ${BUILD_ARTIFACTSTAGINGDIRECTORY}
              tar czvf Scopy-macos${MACOS_VERSION}.tar.gz ${DEPLOY_FILE}
            else
              echo "Scopy.dmg does not exists"
            fi
            ls -la ${BUILD_ARTIFACTSTAGINGDIRECTORY}
      displayName: 'Rename and copy artifact'
      workingDirectory: $(Build.Repository.LocalPath)
    - task: GithubRelease@1
      displayName: 'Push to continuous release'
      condition: and(
                    succeeded(),
                    or(
                      eq(variables['Build.SourceBranch'], 'refs/heads/main'),
                      eq(variables['System.PullRequest.TargetBranch'], 'refs/heads/main')
                      )
                    ) # push artifacts only if pipeline completed successfully and either the build is for the main branch or there is a PR into main branch
      inputs:
        githubConnection: scopy_continuous_release
        repositoryName: $(Build.Repository.Name)
        action: edit
        tag: continous
        assets: $(Build.ArtifactStagingDirectory)/Scopy*.tar.gz
        assetUploadMode: replace
        isPreRelease: true
        addChangeLog: false
    - task: PublishPipelineArtifact@1
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifactName: '$(artifactName)'
